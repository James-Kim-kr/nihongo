"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _classCallCheck = (__webpack_require__(/*! @swc/helpers/lib/_class_call_check.js */ \"./node_modules/@swc/helpers/lib/_class_call_check.js\")[\"default\"]);\nvar _createClass = (__webpack_require__(/*! @swc/helpers/lib/_create_class.js */ \"./node_modules/@swc/helpers/lib/_create_class.js\")[\"default\"]);\nvar _inherits = (__webpack_require__(/*! @swc/helpers/lib/_inherits.js */ \"./node_modules/@swc/helpers/lib/_inherits.js\")[\"default\"]);\nvar _interopRequireWildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _slicedToArray = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\nvar _createSuper = (__webpack_require__(/*! @swc/helpers/lib/_create_super.js */ \"./node_modules/@swc/helpers/lib/_create_super.js\")[\"default\"]);\nvar _tsGenerator = (__webpack_require__(/*! @swc/helpers/lib/_ts_generator.js */ \"./node_modules/@swc/helpers/lib/_ts_generator.js\")[\"default\"]);\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.initialize = initialize;\nexports.hydrate = hydrate;\nexports.emitter = exports.router = exports.version = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"./node_modules/next/dist/build/polyfills/polyfill-module.js\");\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _headManagerContext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js?7c760\");\nvar _mitt = _interop_require_default(__webpack_require__(/*! ../shared/lib/mitt */ \"./node_modules/next/dist/shared/lib/mitt.js?4b500\"));\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js?c1db0\");\nvar _isDynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js?eddd0\");\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js?76590\");\nvar _runtimeConfig = __webpack_require__(/*! ../shared/lib/runtime-config */ \"./node_modules/next/dist/shared/lib/runtime-config.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js?b9c40\");\nvar _portal = __webpack_require__(/*! ./portal */ \"./node_modules/next/dist/client/portal/index.js\");\nvar _headManager = _interop_require_default(__webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js?a5c10\"));\nvar _pageLoader = _interop_require_default(__webpack_require__(/*! ./page-loader */ \"./node_modules/next/dist/client/page-loader.js\"));\nvar _performanceRelayer = _interop_require_default(__webpack_require__(/*! ./performance-relayer */ \"./node_modules/next/dist/client/performance-relayer.js\"));\nvar _routeAnnouncer = __webpack_require__(/*! ./route-announcer */ \"./node_modules/next/dist/client/route-announcer.js\");\nvar _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js?7c690\");\nvar _isError = __webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js?178e0\");\nvar _imageConfigContext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\nvar _removeBasePath = __webpack_require__(/*! ./remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js?a4f30\");\nvar _hasBasePath = __webpack_require__(/*! ./has-base-path */ \"./node_modules/next/dist/client/has-base-path.js?dfae0\");\nvar ReactDOM =  false ? 0 : __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\nvar version = \"12.3.4\";\nexports.version = version;\nvar router;\nexports.router = router;\nvar emitter = (0, _mitt).default();\nexports.emitter = emitter;\nvar looseToArray = function(input) {\n    return [].slice.call(input);\n};\nvar initialData;\nvar defaultLocale = undefined;\nvar asPath;\nvar pageLoader;\nvar appElement;\nvar headManager;\nvar initialMatchesMiddleware = false;\nvar lastAppProps;\nvar lastRenderReject;\nvar webpackHMR;\nvar CachedApp, onPerfEntry;\nvar CachedComponent;\nself.__next_require__ = __webpack_require__;\nvar Container = /*#__PURE__*/ function(_Component) {\n    \"use strict\";\n    _inherits(Container, _Component);\n    var _super = _createSuper(Container);\n    function Container() {\n        _classCallCheck(this, Container);\n        return _super.apply(this, arguments);\n    }\n    _createClass(Container, [\n        {\n            key: \"componentDidCatch\",\n            value: function componentDidCatch(componentErr, info) {\n                this.props.fn(componentErr, info);\n            }\n        },\n        {\n            key: \"componentDidMount\",\n            value: function componentDidMount() {\n                this.scrollToHash();\n                // We need to replace the router state if:\n                // - the page was (auto) exported and has a query string or search (hash)\n                // - it was auto exported and is a dynamic route (to provide params)\n                // - if it is a client-side skeleton (fallback render)\n                // - if middleware matches the current page (may have rewrite params)\n                // - if rewrites in next.config.js match (may have rewrite params)\n                if (router.isSsr && // We don't update for 404 requests as this can modify\n                // the asPath unexpectedly e.g. adding basePath when\n                // it wasn't originally present\n                initialData.page !== \"/404\" && initialData.page !== \"/_error\" && (initialData.isFallback || initialData.nextExport && ((0, _isDynamic).isDynamicRoute(router.pathname) || location.search || false || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || false || initialMatchesMiddleware))) {\n                    // update query on mount for exported pages\n                    router.replace(router.pathname + \"?\" + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(router.query), new URLSearchParams(location.search))), asPath, {\n                        // @ts-ignore\n                        // WARNING: `_h` is an internal option for handing Next.js\n                        // client-side hydration. Your app should _never_ use this property.\n                        // It may change at any time without notice.\n                        _h: 1,\n                        // Fallback pages must trigger the data fetch, so the transition is\n                        // not shallow.\n                        // Other pages (strictly updating query) happens shallowly, as data\n                        // requirements would already be present.\n                        shallow: !initialData.isFallback && !initialMatchesMiddleware\n                    }).catch(function(err) {\n                        if (!err.cancelled) throw err;\n                    });\n                }\n            }\n        },\n        {\n            key: \"componentDidUpdate\",\n            value: function componentDidUpdate() {\n                this.scrollToHash();\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash() {\n                var hash = location.hash;\n                hash = hash && hash.substring(1);\n                if (!hash) return;\n                var el = document.getElementById(hash);\n                if (!el) return;\n                // If we call scrollIntoView() in here without a setTimeout\n                // it won't scroll properly.\n                setTimeout(function() {\n                    return el.scrollIntoView();\n                }, 0);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render() {\n                if (false) {} else {\n                    var ReactDevOverlay = (__webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\").ReactDevOverlay);\n                    return /*#__PURE__*/ _react.default.createElement(ReactDevOverlay, null, this.props.children);\n                }\n            }\n        }\n    ]);\n    return Container;\n}(_react.default.Component);\nfunction initialize() {\n    return _initialize.apply(this, arguments);\n}\nfunction _initialize() {\n    _initialize = _async_to_generator(function() {\n        var opts, prefix, normalizeLocalePath, detectDomainLocale, parseRelativeUrl, formatUrl, parsedAs, localePathResult, detectedDomain, initScriptLoader, register;\n        var _arguments = arguments;\n        return _tsGenerator(this, function(_state) {\n            opts = _arguments.length > 0 && _arguments[0] !== void 0 ? _arguments[0] : {};\n            // This makes sure this specific lines are removed in production\n            if (true) {\n                webpackHMR = opts.webpackHMR;\n            }\n            initialData = JSON.parse(document.getElementById(\"__NEXT_DATA__\").textContent);\n            window.__NEXT_DATA__ = initialData;\n            defaultLocale = initialData.defaultLocale;\n            prefix = initialData.assetPrefix || \"\";\n            // With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time\n            // So, this is how we do it in the client side at runtime\n            __webpack_require__.p = \"\".concat(prefix, \"/_next/\") //eslint-disable-line\n            ;\n            // Initialize next/config with the environment configuration\n            (0, _runtimeConfig).setConfig({\n                serverRuntimeConfig: {},\n                publicRuntimeConfig: initialData.runtimeConfig || {}\n            });\n            asPath = (0, _utils).getURL();\n            // make sure not to attempt stripping basePath for 404s\n            if ((0, _hasBasePath).hasBasePath(asPath)) {\n                asPath = (0, _removeBasePath).removeBasePath(asPath);\n            }\n            if (false) {}\n            if (initialData.scriptLoader) {\n                initScriptLoader = (__webpack_require__(/*! ./script */ \"./node_modules/next/dist/client/script.js?2e780\").initScriptLoader);\n                initScriptLoader(initialData.scriptLoader);\n            }\n            pageLoader = new _pageLoader.default(initialData.buildId, prefix);\n            register = function(param) {\n                var _param = _slicedToArray(param, 2), r = _param[0], f = _param[1];\n                return pageLoader.routeLoader.onEntrypoint(r, f);\n            };\n            if (window.__NEXT_P) {\n                // Defer page registration for another tick. This will increase the overall\n                // latency in hydrating the page, but reduce the total blocking time.\n                window.__NEXT_P.map(function(p) {\n                    return setTimeout(function() {\n                        return register(p);\n                    }, 0);\n                });\n            }\n            window.__NEXT_P = [];\n            window.__NEXT_P.push = register;\n            headManager = (0, _headManager).default();\n            headManager.getIsSsr = function() {\n                return router.isSsr;\n            };\n            appElement = document.getElementById(\"__next\");\n            return [\n                2,\n                {\n                    assetPrefix: prefix\n                }\n            ];\n        });\n    });\n    return _initialize.apply(this, arguments);\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ _react.default.createElement(App, Object.assign({}, appProps));\n}\nfunction AppContainer(param) {\n    var children = param.children;\n    return /*#__PURE__*/ _react.default.createElement(Container, {\n        fn: function(error) {\n            return(// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            renderError({\n                App: CachedApp,\n                err: error\n            }).catch(function(err) {\n                return console.error(\"Error rendering page: \", err);\n            }));\n        }\n    }, /*#__PURE__*/ _react.default.createElement(_routerContext.RouterContext.Provider, {\n        value: (0, _router).makePublicRouterInstance(router)\n    }, /*#__PURE__*/ _react.default.createElement(_headManagerContext.HeadManagerContext.Provider, {\n        value: headManager\n    }, /*#__PURE__*/ _react.default.createElement(_imageConfigContext.ImageConfigContext.Provider, {\n        value: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[\"example.com\"],\"remotePatterns\":[]}\n    }, children))));\n}\n_c = AppContainer;\nvar wrapApp = function(App) {\n    return function(wrappedAppProps) {\n        var appProps = _extends({}, wrappedAppProps, {\n            Component: CachedComponent,\n            err: initialData.err,\n            router: router\n        });\n        return /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps));\n    };\n};\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    var App = renderErrorProps.App, err = renderErrorProps.err;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        webpackHMR.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        // TODO: Fix disabled eslint rule\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return doRender({\n            App: function() {\n                return null;\n            },\n            props: {},\n            Component: function() {\n                return null;\n            },\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage(\"/_error\").then(function(param) {\n        var ErrorComponent = param.page, styleSheets = param.styleSheets;\n        return (lastAppProps == null ? void 0 : lastAppProps.Component) === ErrorComponent ? Promise.resolve().then(function() {\n            return /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ../pages/_error */ \"./node_modules/next/dist/pages/_error.js?f25f0\"));\n        }).then(function(errorModule) {\n            return Promise.resolve().then(function() {\n                return /*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ../pages/_app */ \"./node_modules/next/dist/pages/_app.js?05dd0\"));\n            }).then(function(appModule) {\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then(function(m) {\n            return {\n                ErrorComponent: m.default,\n                styleSheets: []\n            };\n        }) : {\n            ErrorComponent: ErrorComponent,\n            styleSheets: styleSheets\n        };\n    }).then(function(param) {\n        var ErrorComponent = param.ErrorComponent, styleSheets = param.styleSheets;\n        var ref;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        var AppTree = wrapApp(App);\n        var appCtx = {\n            Component: ErrorComponent,\n            AppTree: AppTree,\n            router: router,\n            ctx: {\n                err: err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath: asPath,\n                AppTree: AppTree\n            }\n        };\n        return Promise.resolve(((ref = renderErrorProps.props) == null ? void 0 : ref.err) ? renderErrorProps.props : (0, _utils).loadGetInitialProps(App, appCtx)).then(function(initProps) {\n            return(// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            doRender(_extends({}, renderErrorProps, {\n                err: err,\n                Component: ErrorComponent,\n                styleSheets: styleSheets,\n                props: initProps\n            })));\n        });\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    var callback = param.callback;\n    _s();\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect(function() {\n        return callback();\n    }, [\n        callback\n    ]);\n    return null;\n}\n_s(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Head;\nvar reactRoot = null;\n// On initial render a hydrate should always happen\nvar shouldHydrate = true;\nfunction clearMarks() {\n    [\n        \"beforeRender\",\n        \"afterHydrate\",\n        \"afterRender\",\n        \"routeChange\"\n    ].forEach(function(mark) {\n        return performance.clearMarks(mark);\n    });\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark(\"afterHydrate\") // mark end of hydration\n    ;\n    performance.measure(\"Next.js-before-hydration\", \"navigationStart\", \"beforeRender\");\n    performance.measure(\"Next.js-hydration\", \"beforeRender\", \"afterHydrate\");\n    if (onPerfEntry) {\n        performance.getEntriesByName(\"Next.js-hydration\").forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark(\"afterRender\") // mark end of render\n    ;\n    var navStartEntries = performance.getEntriesByName(\"routeChange\", \"mark\");\n    if (!navStartEntries.length) return;\n    performance.measure(\"Next.js-route-change-to-render\", navStartEntries[0].name, \"beforeRender\");\n    performance.measure(\"Next.js-render\", \"beforeRender\", \"afterRender\");\n    if (onPerfEntry) {\n        performance.getEntriesByName(\"Next.js-render\").forEach(onPerfEntry);\n        performance.getEntriesByName(\"Next.js-route-change-to-render\").forEach(onPerfEntry);\n    }\n    clearMarks();\n    [\n        \"Next.js-route-change-to-render\",\n        \"Next.js-render\"\n    ].forEach(function(measure) {\n        return performance.clearMeasures(measure);\n    });\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark(\"beforeRender\");\n    }\n    var reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (false) { var startTransition; } else {\n        // The check for `.hydrate` is there to support React alternatives like preact\n        if (shouldHydrate) {\n            ReactDOM.hydrate(reactEl, domEl);\n            shouldHydrate = false;\n        } else {\n            ReactDOM.render(reactEl, domEl);\n        }\n    }\n}\nfunction Root(param) {\n    var callbacks = param.callbacks, children = param.children;\n    _s1();\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect(function() {\n        return callbacks.forEach(function(callback) {\n            return callback();\n        });\n    }, [\n        callbacks\n    ]);\n    // We should ask to measure the Web Vitals after rendering completes so we\n    // don't cause any hydration delay:\n    _react.default.useEffect(function() {\n        (0, _performanceRelayer).default(onPerfEntry);\n    }, []);\n    if (false) {}\n    return children;\n}\n_s1(Root, \"Gjgl5rfcc2T4sFnfEMfRvL6K4Q4=\");\n_c2 = Root;\nfunction doRender(input) {\n    var onStart = // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        \"development\" !== \"production\") {\n            return false;\n        }\n        var currentStyleTags = looseToArray(document.querySelectorAll(\"style[data-n-href]\"));\n        var currentHrefs = new Set(currentStyleTags.map(function(tag) {\n            return tag.getAttribute(\"data-n-href\");\n        }));\n        var noscript = document.querySelector(\"noscript[data-n-css]\");\n        var nonce = noscript == null ? void 0 : noscript.getAttribute(\"data-n-css\");\n        styleSheets.forEach(function(param) {\n            var href = param.href, text = param.text;\n            if (!currentHrefs.has(href)) {\n                var styleTag = document.createElement(\"style\");\n                styleTag.setAttribute(\"data-n-href\", href);\n                styleTag.setAttribute(\"media\", \"x\");\n                if (nonce) {\n                    styleTag.setAttribute(\"nonce\", nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    };\n    var onHeadCommit = function onHeadCommit() {\n        if (// unless we're in production:\n        false) { var referenceNode, idx, currentHrefs, currentStyleTags, desiredHrefs; }\n        if (input.scroll) {\n            var htmlElement = document.documentElement;\n            var existing = htmlElement.style.scrollBehavior;\n            htmlElement.style.scrollBehavior = \"auto\";\n            window.scrollTo(input.scroll.x, input.scroll.y);\n            htmlElement.style.scrollBehavior = existing;\n        }\n    };\n    var onRootCommit = function onRootCommit() {\n        resolvePromise();\n    };\n    var App = input.App, Component = input.Component, props = input.props, err = input.err;\n    var styleSheets = \"initial\" in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    var appProps = _extends({}, props, {\n        Component: Component,\n        err: err,\n        router: router\n    });\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    var canceled = false;\n    var resolvePromise;\n    var renderPromise = new Promise(function(resolve, reject) {\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = function() {\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = function() {\n            canceled = true;\n            lastRenderReject = null;\n            var error = new Error(\"Cancel rendering route\");\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    onStart();\n    var elem = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Head, {\n        callback: onHeadCommit\n    }), /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps), /*#__PURE__*/ _react.default.createElement(_portal.Portal, {\n        type: \"next-route-announcer\"\n    }, /*#__PURE__*/ _react.default.createElement(_routeAnnouncer.RouteAnnouncer, null))));\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, function(callback) {\n        return /*#__PURE__*/ _react.default.createElement(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ]\n        },  true ? /*#__PURE__*/ _react.default.createElement(_react.default.StrictMode, null, elem) : 0);\n    });\n    return renderPromise;\n}\nfunction render(renderingProps) {\n    return _render.apply(this, arguments);\n}\nfunction _render() {\n    _render = _async_to_generator(function(renderingProps) {\n        var err, renderErr;\n        return _tsGenerator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    if (!renderingProps.err) return [\n                        3,\n                        2\n                    ];\n                    return [\n                        4,\n                        renderError(renderingProps)\n                    ];\n                case 1:\n                    _state.sent();\n                    return [\n                        2\n                    ];\n                case 2:\n                    _state.trys.push([\n                        2,\n                        4,\n                        ,\n                        6\n                    ]);\n                    return [\n                        4,\n                        doRender(renderingProps)\n                    ];\n                case 3:\n                    _state.sent();\n                    return [\n                        3,\n                        6\n                    ];\n                case 4:\n                    err = _state.sent();\n                    renderErr = (0, _isError).getProperError(err);\n                    // bubble up cancelation errors\n                    if (renderErr.cancelled) {\n                        throw renderErr;\n                    }\n                    if (true) {\n                        // Ensure this error is displayed in the overlay in development\n                        setTimeout(function() {\n                            throw renderErr;\n                        });\n                    }\n                    return [\n                        4,\n                        renderError(_extends({}, renderingProps, {\n                            err: renderErr\n                        }))\n                    ];\n                case 5:\n                    _state.sent();\n                    return [\n                        3,\n                        6\n                    ];\n                case 6:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _render.apply(this, arguments);\n}\nfunction hydrate(opts) {\n    return _hydrate.apply(this, arguments);\n}\nfunction _hydrate() {\n    _hydrate = _async_to_generator(function(opts) {\n        var initialErr, appEntrypoint, app, mod, pageEntrypoint, _tmp, isValidElementType, error1, getServerError, renderCtx;\n        return _tsGenerator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    initialErr = initialData.err;\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        6,\n                        ,\n                        7\n                    ]);\n                    return [\n                        4,\n                        pageLoader.routeLoader.whenEntrypoint(\"/_app\")\n                    ];\n                case 2:\n                    appEntrypoint = _state.sent();\n                    if (\"error\" in appEntrypoint) {\n                        throw appEntrypoint.error;\n                    }\n                    app = appEntrypoint.component, mod = appEntrypoint.exports;\n                    CachedApp = app;\n                    if (mod && mod.reportWebVitals) {\n                        onPerfEntry = function(param) {\n                            var id = param.id, name = param.name, startTime = param.startTime, value = param.value, duration = param.duration, entryType = param.entryType, entries = param.entries;\n                            // Combines timestamp with random number for unique ID\n                            var uniqueID = \"\".concat(Date.now(), \"-\").concat(Math.floor(Math.random() * (9e12 - 1)) + 1e12);\n                            var perfStartEntry;\n                            if (entries && entries.length) {\n                                perfStartEntry = entries[0].startTime;\n                            }\n                            var webVitals = {\n                                id: id || uniqueID,\n                                name: name,\n                                startTime: startTime || perfStartEntry,\n                                value: value == null ? duration : value,\n                                label: entryType === \"mark\" || entryType === \"measure\" ? \"custom\" : \"web-vital\"\n                            };\n                            mod.reportWebVitals(webVitals);\n                        };\n                    }\n                    if (!// error, so we need to skip waiting for the entrypoint.\n                    ( true && initialData.err)) return [\n                        3,\n                        3\n                    ];\n                    _tmp = {\n                        error: initialData.err\n                    };\n                    return [\n                        3,\n                        5\n                    ];\n                case 3:\n                    return [\n                        4,\n                        pageLoader.routeLoader.whenEntrypoint(initialData.page)\n                    ];\n                case 4:\n                    _tmp = _state.sent();\n                    _state.label = 5;\n                case 5:\n                    pageEntrypoint = _tmp;\n                    if (\"error\" in pageEntrypoint) {\n                        throw pageEntrypoint.error;\n                    }\n                    CachedComponent = pageEntrypoint.component;\n                    if (true) {\n                        isValidElementType = (__webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\").isValidElementType);\n                        if (!isValidElementType(CachedComponent)) {\n                            throw new Error('The default export is not a React Component in page: \"'.concat(initialData.page, '\"'));\n                        }\n                    }\n                    return [\n                        3,\n                        7\n                    ];\n                case 6:\n                    error1 = _state.sent();\n                    // This catches errors like throwing in the top level of a module\n                    initialErr = (0, _isError).getProperError(error1);\n                    return [\n                        3,\n                        7\n                    ];\n                case 7:\n                    if (true) {\n                        getServerError = (__webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\").getServerError);\n                        // Server-side runtime errors need to be re-thrown on the client-side so\n                        // that the overlay is rendered.\n                        if (initialErr) {\n                            if (initialErr === initialData.err) {\n                                setTimeout(function() {\n                                    var error;\n                                    try {\n                                        // Generate a new error object. We `throw` it because some browsers\n                                        // will set the `stack` when thrown, and we want to ensure ours is\n                                        // not overridden when we re-throw it below.\n                                        throw new Error(initialErr.message);\n                                    } catch (e) {\n                                        error = e;\n                                    }\n                                    error.name = initialErr.name;\n                                    error.stack = initialErr.stack;\n                                    throw getServerError(error, initialErr.source);\n                                });\n                            } else {\n                                setTimeout(function() {\n                                    throw initialErr;\n                                });\n                            }\n                        }\n                    }\n                    if (!window.__NEXT_PRELOADREADY) return [\n                        3,\n                        9\n                    ];\n                    return [\n                        4,\n                        window.__NEXT_PRELOADREADY(initialData.dynamicIds)\n                    ];\n                case 8:\n                    _state.sent();\n                    _state.label = 9;\n                case 9:\n                    exports.router = router = (0, _router).createRouter(initialData.page, initialData.query, asPath, {\n                        initialProps: initialData.props,\n                        pageLoader: pageLoader,\n                        App: CachedApp,\n                        Component: CachedComponent,\n                        wrapApp: wrapApp,\n                        err: initialErr,\n                        isFallback: Boolean(initialData.isFallback),\n                        subscription: function(info, App, scroll) {\n                            return render(Object.assign({}, info, {\n                                App: App,\n                                scroll: scroll\n                            }));\n                        },\n                        locale: initialData.locale,\n                        locales: initialData.locales,\n                        defaultLocale: defaultLocale,\n                        domainLocales: initialData.domainLocales,\n                        isPreview: initialData.isPreview\n                    });\n                    return [\n                        4,\n                        router._initialMatchesMiddlewarePromise\n                    ];\n                case 10:\n                    initialMatchesMiddleware = _state.sent();\n                    renderCtx = {\n                        App: CachedApp,\n                        initial: true,\n                        Component: CachedComponent,\n                        props: initialData.props,\n                        err: initialErr\n                    };\n                    if (!(opts == null ? void 0 : opts.beforeRender)) return [\n                        3,\n                        12\n                    ];\n                    return [\n                        4,\n                        opts.beforeRender()\n                    ];\n                case 11:\n                    _state.sent();\n                    _state.label = 12;\n                case 12:\n                    render(renderCtx);\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _hydrate.apply(this, arguments);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7Ozs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztJQUN6Q0csS0FBSyxFQUFFLElBQUk7Q0FDZCxFQUFDLENBQUM7QUFDSEQsa0JBQWtCLEdBQUdFLFVBQVUsQ0FBQztBQUNoQ0YsZUFBZSxHQUFHRyxPQUFPLENBQUM7QUFDMUJILGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxlQUFlLEdBQUcsS0FBSyxDQUFDLENBQUM7QUFDNUQsSUFBSU8sbUJBQW1CLEdBQUdDLHlJQUEwRDtBQUNwRixJQUFJRSxRQUFRLEdBQUdGLG1IQUErQztBQUM5RCxJQUFJRyx3QkFBd0IsR0FBR0gsbUpBQStEO0FBQzlGLElBQUlJLHlCQUF5QixHQUFHSixxSkFBZ0U7QUFDaEdBLG1CQUFPLENBQUMsdUdBQW9DLENBQUMsQ0FBQztBQUM5QyxJQUFJSyxNQUFNLEdBQUdGLHdCQUF3QixDQUFDSCxtQkFBTyxDQUFDLDRDQUFPLENBQUMsQ0FBQztBQUN2RCxJQUFJTSxtQkFBbUIsR0FBR04sbUJBQU8sQ0FBQyw2R0FBb0MsQ0FBQztBQUN2RSxJQUFJTyxLQUFLLEdBQUdKLHdCQUF3QixDQUFDSCxtQkFBTyxDQUFDLDZFQUFvQixDQUFDLENBQUM7QUFDbkUsSUFBSVEsY0FBYyxHQUFHUixtQkFBTyxDQUFDLGlHQUE4QixDQUFDO0FBQzVELElBQUlTLFVBQVUsR0FBR1QsbUJBQU8sQ0FBQyxtSEFBdUMsQ0FBQztBQUNqRSxJQUFJVSxZQUFZLEdBQUdWLG1CQUFPLENBQUMscUhBQXdDLENBQUM7QUFDcEUsSUFBSVcsY0FBYyxHQUFHWCxtQkFBTyxDQUFDLDJGQUE4QixDQUFDO0FBQzVELElBQUlZLE1BQU0sR0FBR1osbUJBQU8sQ0FBQywrRUFBcUIsQ0FBQztBQUMzQyxJQUFJYSxPQUFPLEdBQUdiLG1CQUFPLENBQUMsaUVBQVUsQ0FBQztBQUNqQyxJQUFJYyxZQUFZLEdBQUdYLHdCQUF3QixDQUFD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YnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW5kZXguanM/NDZjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaW5pdGlhbGl6ZSA9IGluaXRpYWxpemU7XG5leHBvcnRzLmh5ZHJhdGUgPSBoeWRyYXRlO1xuZXhwb3J0cy5lbWl0dGVyID0gZXhwb3J0cy5yb3V0ZXIgPSBleHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG52YXIgX2FzeW5jX3RvX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19hc3luY190b19nZW5lcmF0b3IuanNcIikuZGVmYXVsdDtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnJlcXVpcmUoXCIuLi9idWlsZC9wb2x5ZmlsbHMvcG9seWZpbGwtbW9kdWxlXCIpO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9oZWFkTWFuYWdlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dFwiKTtcbnZhciBfbWl0dCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9taXR0XCIpKTtcbnZhciBfcm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0XCIpO1xudmFyIF9pc0R5bmFtaWMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pY1wiKTtcbnZhciBfcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmdcIik7XG52YXIgX3J1bnRpbWVDb25maWcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9ydW50aW1lLWNvbmZpZ1wiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbnZhciBfcG9ydGFsID0gcmVxdWlyZShcIi4vcG9ydGFsXCIpO1xudmFyIF9oZWFkTWFuYWdlciA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi9oZWFkLW1hbmFnZXJcIikpO1xudmFyIF9wYWdlTG9hZGVyID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuL3BhZ2UtbG9hZGVyXCIpKTtcbnZhciBfcGVyZm9ybWFuY2VSZWxheWVyID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuL3BlcmZvcm1hbmNlLXJlbGF5ZXJcIikpO1xudmFyIF9yb3V0ZUFubm91bmNlciA9IHJlcXVpcmUoXCIuL3JvdXRlLWFubm91bmNlclwiKTtcbnZhciBfcm91dGVyID0gcmVxdWlyZShcIi4vcm91dGVyXCIpO1xudmFyIF9pc0Vycm9yID0gcmVxdWlyZShcIi4uL2xpYi9pcy1lcnJvclwiKTtcbnZhciBfaW1hZ2VDb25maWdDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHRcIik7XG52YXIgX3JlbW92ZUJhc2VQYXRoID0gcmVxdWlyZShcIi4vcmVtb3ZlLWJhc2UtcGF0aFwiKTtcbnZhciBfaGFzQmFzZVBhdGggPSByZXF1aXJlKFwiLi9oYXMtYmFzZS1wYXRoXCIpO1xuY29uc3QgUmVhY3RET00gPSBwcm9jZXNzLmVudi5fX05FWFRfUkVBQ1RfUk9PVCA/IHJlcXVpcmUoJ3JlYWN0LWRvbS9jbGllbnQnKSA6IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuY29uc3QgdmVyc2lvbiA9IFwiMTIuMy40XCI7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xubGV0IHJvdXRlcjtcbmV4cG9ydHMucm91dGVyID0gcm91dGVyO1xuY29uc3QgZW1pdHRlciA9ICgwLCBfbWl0dCkuZGVmYXVsdCgpO1xuZXhwb3J0cy5lbWl0dGVyID0gZW1pdHRlcjtcbmNvbnN0IGxvb3NlVG9BcnJheSA9IChpbnB1dCk9PltdLnNsaWNlLmNhbGwoaW5wdXQpO1xubGV0IGluaXRpYWxEYXRhO1xubGV0IGRlZmF1bHRMb2NhbGUgPSB1bmRlZmluZWQ7XG5sZXQgYXNQYXRoO1xubGV0IHBhZ2VMb2FkZXI7XG5sZXQgYXBwRWxlbWVudDtcbmxldCBoZWFkTWFuYWdlcjtcbmxldCBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUgPSBmYWxzZTtcbmxldCBsYXN0QXBwUHJvcHM7XG5sZXQgbGFzdFJlbmRlclJlamVjdDtcbmxldCB3ZWJwYWNrSE1SO1xubGV0IENhY2hlZEFwcCwgb25QZXJmRW50cnk7XG5sZXQgQ2FjaGVkQ29tcG9uZW50O1xuc2VsZi5fX25leHRfcmVxdWlyZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXztcbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkQ2F0Y2goY29tcG9uZW50RXJyLCBpbmZvKSB7XG4gICAgICAgIHRoaXMucHJvcHMuZm4oY29tcG9uZW50RXJyLCBpbmZvKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKCk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgcm91dGVyIHN0YXRlIGlmOlxuICAgICAgICAvLyAtIHRoZSBwYWdlIHdhcyAoYXV0bykgZXhwb3J0ZWQgYW5kIGhhcyBhIHF1ZXJ5IHN0cmluZyBvciBzZWFyY2ggKGhhc2gpXG4gICAgICAgIC8vIC0gaXQgd2FzIGF1dG8gZXhwb3J0ZWQgYW5kIGlzIGEgZHluYW1pYyByb3V0ZSAodG8gcHJvdmlkZSBwYXJhbXMpXG4gICAgICAgIC8vIC0gaWYgaXQgaXMgYSBjbGllbnQtc2lkZSBza2VsZXRvbiAoZmFsbGJhY2sgcmVuZGVyKVxuICAgICAgICAvLyAtIGlmIG1pZGRsZXdhcmUgbWF0Y2hlcyB0aGUgY3VycmVudCBwYWdlIChtYXkgaGF2ZSByZXdyaXRlIHBhcmFtcylcbiAgICAgICAgLy8gLSBpZiByZXdyaXRlcyBpbiBuZXh0LmNvbmZpZy5qcyBtYXRjaCAobWF5IGhhdmUgcmV3cml0ZSBwYXJhbXMpXG4gICAgICAgIGlmIChyb3V0ZXIuaXNTc3IgJiYgLy8gV2UgZG9uJ3QgdXBkYXRlIGZvciA0MDQgcmVxdWVzdHMgYXMgdGhpcyBjYW4gbW9kaWZ5XG4gICAgICAgIC8vIHRoZSBhc1BhdGggdW5leHBlY3RlZGx5IGUuZy4gYWRkaW5nIGJhc2VQYXRoIHdoZW5cbiAgICAgICAgLy8gaXQgd2Fzbid0IG9yaWdpbmFsbHkgcHJlc2VudFxuICAgICAgICBpbml0aWFsRGF0YS5wYWdlICE9PSAnLzQwNCcgJiYgaW5pdGlhbERhdGEucGFnZSAhPT0gJy9fZXJyb3InICYmIChpbml0aWFsRGF0YS5pc0ZhbGxiYWNrIHx8IGluaXRpYWxEYXRhLm5leHRFeHBvcnQgJiYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyb3V0ZXIucGF0aG5hbWUpIHx8IGxvY2F0aW9uLnNlYXJjaCB8fCBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTIHx8IGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSkgfHwgaW5pdGlhbERhdGEucHJvcHMgJiYgaW5pdGlhbERhdGEucHJvcHMuX19OX1NTRyAmJiAobG9jYXRpb24uc2VhcmNoIHx8IHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgfHwgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlKSkpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBxdWVyeSBvbiBtb3VudCBmb3IgZXhwb3J0ZWQgcGFnZXNcbiAgICAgICAgICAgIHJvdXRlci5yZXBsYWNlKHJvdXRlci5wYXRobmFtZSArICc/JyArIFN0cmluZygoMCwgX3F1ZXJ5c3RyaW5nKS5hc3NpZ24oKDAsIF9xdWVyeXN0cmluZykudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhyb3V0ZXIucXVlcnkpLCBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCkpKSwgYXNQYXRoLCB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanNcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQtc2lkZSBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIEl0IG1heSBjaGFuZ2UgYXQgYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgICAgICAgICAgX2g6IDEsXG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgcGFnZXMgbXVzdCB0cmlnZ2VyIHRoZSBkYXRhIGZldGNoLCBzbyB0aGUgdHJhbnNpdGlvbiBpc1xuICAgICAgICAgICAgICAgIC8vIG5vdCBzaGFsbG93LlxuICAgICAgICAgICAgICAgIC8vIE90aGVyIHBhZ2VzIChzdHJpY3RseSB1cGRhdGluZyBxdWVyeSkgaGFwcGVucyBzaGFsbG93bHksIGFzIGRhdGFcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlbWVudHMgd291bGQgYWxyZWFkeSBiZSBwcmVzZW50LlxuICAgICAgICAgICAgICAgIHNoYWxsb3c6ICFpbml0aWFsRGF0YS5pc0ZhbGxiYWNrICYmICFpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIuY2FuY2VsbGVkKSB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKCk7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaCgpIHtcbiAgICAgICAgbGV0IHsgaGFzaCAgfSA9IGxvY2F0aW9uO1xuICAgICAgICBoYXNoID0gaGFzaCAmJiBoYXNoLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKCFoYXNoKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCk7XG4gICAgICAgIGlmICghZWwpIHJldHVybjtcbiAgICAgICAgLy8gSWYgd2UgY2FsbCBzY3JvbGxJbnRvVmlldygpIGluIGhlcmUgd2l0aG91dCBhIHNldFRpbWVvdXRcbiAgICAgICAgLy8gaXQgd29uJ3Qgc2Nyb2xsIHByb3Blcmx5LlxuICAgICAgICBzZXRUaW1lb3V0KCgpPT5lbC5zY3JvbGxJbnRvVmlldygpLCAwKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IFJlYWN0RGV2T3ZlcmxheSAsICB9ID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2Rpc3QvY2xpZW50Jyk7XG4gICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0RGV2T3ZlcmxheSwgbnVsbCwgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIHJldHVybiBfaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2luaXRpYWxpemUoKSB7XG4gICAgX2luaXRpYWxpemUgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKihvcHRzID0ge30pIHtcbiAgICAgICAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoaXMgc3BlY2lmaWMgbGluZXMgYXJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIHdlYnBhY2tITVIgPSBvcHRzLndlYnBhY2tITVI7XG4gICAgICAgIH1cbiAgICAgICAgaW5pdGlhbERhdGEgPSBKU09OLnBhcnNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX05FWFRfREFUQV9fJykudGV4dENvbnRlbnQpO1xuICAgICAgICB3aW5kb3cuX19ORVhUX0RBVEFfXyA9IGluaXRpYWxEYXRhO1xuICAgICAgICBkZWZhdWx0TG9jYWxlID0gaW5pdGlhbERhdGEuZGVmYXVsdExvY2FsZTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gaW5pdGlhbERhdGEuYXNzZXRQcmVmaXggfHwgJyc7XG4gICAgICAgIC8vIFdpdGggZHluYW1pYyBhc3NldFByZWZpeCBpdCdzIG5vIGxvbmdlciBwb3NzaWJsZSB0byBzZXQgYXNzZXRQcmVmaXggYXQgdGhlIGJ1aWxkIHRpbWVcbiAgICAgICAgLy8gU28sIHRoaXMgaXMgaG93IHdlIGRvIGl0IGluIHRoZSBjbGllbnQgc2lkZSBhdCBydW50aW1lXG4gICAgICAgIF9fd2VicGFja19wdWJsaWNfcGF0aF9fID0gYCR7cHJlZml4fS9fbmV4dC9gIC8vZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICA7XG4gICAgICAgIC8vIEluaXRpYWxpemUgbmV4dC9jb25maWcgd2l0aCB0aGUgZW52aXJvbm1lbnQgY29uZmlndXJhdGlvblxuICAgICAgICAoMCwgX3J1bnRpbWVDb25maWcpLnNldENvbmZpZyh7XG4gICAgICAgICAgICBzZXJ2ZXJSdW50aW1lQ29uZmlnOiB7fSxcbiAgICAgICAgICAgIHB1YmxpY1J1bnRpbWVDb25maWc6IGluaXRpYWxEYXRhLnJ1bnRpbWVDb25maWcgfHwge31cbiAgICAgICAgfSk7XG4gICAgICAgIGFzUGF0aCA9ICgwLCBfdXRpbHMpLmdldFVSTCgpO1xuICAgICAgICAvLyBtYWtlIHN1cmUgbm90IHRvIGF0dGVtcHQgc3RyaXBwaW5nIGJhc2VQYXRoIGZvciA0MDRzXG4gICAgICAgIGlmICgoMCwgX2hhc0Jhc2VQYXRoKS5oYXNCYXNlUGF0aChhc1BhdGgpKSB7XG4gICAgICAgICAgICBhc1BhdGggPSAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChhc1BhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5vcm1hbGl6ZUxvY2FsZVBhdGggIH0gPSByZXF1aXJlKCcuLi9zaGFyZWQvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJyk7XG4gICAgICAgICAgICBjb25zdCB7IGRldGVjdERvbWFpbkxvY2FsZSAgfSA9IHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZScpO1xuICAgICAgICAgICAgY29uc3QgeyBwYXJzZVJlbGF0aXZlVXJsICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJyk7XG4gICAgICAgICAgICBjb25zdCB7IGZvcm1hdFVybCAgfSA9IHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnKTtcbiAgICAgICAgICAgIGlmIChpbml0aWFsRGF0YS5sb2NhbGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGFzUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGFyc2VkQXMucGF0aG5hbWUsIGluaXRpYWxEYXRhLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoID0gZm9ybWF0VXJsKHBhcnNlZEFzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXJpdmUgdGhlIGRlZmF1bHQgbG9jYWxlIGlmIGl0IHdhc24ndCBkZXRlY3RlZCBpbiB0aGUgYXNQYXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHdlIGRvbid0IHByZXJlbmRlciBzdGF0aWMgcGFnZXMgd2l0aCBhbGwgcG9zc2libGUgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAvLyBsb2NhbGVzXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGUgPSBpbml0aWFsRGF0YS5sb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgZGV0ZWN0aW5nIGRlZmF1bHQgbG9jYWxlIGJhc2VkIG9uIGhvc3RuYW1lXG4gICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fRE9NQUlOUywgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpbnZlc3RpZ2F0ZSBpZiBkZWZhdWx0TG9jYWxlIG5lZWRzIHRvIGJlIHBvcHVsYXRlZCBhZnRlclxuICAgICAgICAgICAgICAgIC8vIGh5ZHJhdGlvbiB0byBwcmV2ZW50IG1pc21hdGNoZWQgcmVuZGVyc1xuICAgICAgICAgICAgICAgIGlmIChkZXRlY3RlZERvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlID0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxEYXRhLnNjcmlwdExvYWRlcikge1xuICAgICAgICAgICAgY29uc3QgeyBpbml0U2NyaXB0TG9hZGVyICB9ID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcbiAgICAgICAgICAgIGluaXRTY3JpcHRMb2FkZXIoaW5pdGlhbERhdGEuc2NyaXB0TG9hZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBwYWdlTG9hZGVyID0gbmV3IF9wYWdlTG9hZGVyLmRlZmF1bHQoaW5pdGlhbERhdGEuYnVpbGRJZCwgcHJlZml4KTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXIgPSAoW3IsIGZdKT0+cGFnZUxvYWRlci5yb3V0ZUxvYWRlci5vbkVudHJ5cG9pbnQociwgZik7XG4gICAgICAgIGlmICh3aW5kb3cuX19ORVhUX1ApIHtcbiAgICAgICAgICAgIC8vIERlZmVyIHBhZ2UgcmVnaXN0cmF0aW9uIGZvciBhbm90aGVyIHRpY2suIFRoaXMgd2lsbCBpbmNyZWFzZSB0aGUgb3ZlcmFsbFxuICAgICAgICAgICAgLy8gbGF0ZW5jeSBpbiBoeWRyYXRpbmcgdGhlIHBhZ2UsIGJ1dCByZWR1Y2UgdGhlIHRvdGFsIGJsb2NraW5nIHRpbWUuXG4gICAgICAgICAgICB3aW5kb3cuX19ORVhUX1AubWFwKChwKT0+c2V0VGltZW91dCgoKT0+cmVnaXN0ZXIocCksIDApKTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuX19ORVhUX1AgPSBbXTtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2ggPSByZWdpc3RlcjtcbiAgICAgICAgaGVhZE1hbmFnZXIgPSAoMCwgX2hlYWRNYW5hZ2VyKS5kZWZhdWx0KCk7XG4gICAgICAgIGhlYWRNYW5hZ2VyLmdldElzU3NyID0gKCk9PntcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXIuaXNTc3I7XG4gICAgICAgIH07XG4gICAgICAgIGFwcEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19uZXh0Jyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3NldFByZWZpeDogcHJlZml4XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIF9pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiByZW5kZXJBcHAoQXBwLCBhcHBQcm9wcykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwLCBPYmplY3QuYXNzaWduKHt9LCBhcHBQcm9wcykpO1xufVxuZnVuY3Rpb24gQXBwQ29udGFpbmVyKHsgY2hpbGRyZW4gIH0pIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbnRhaW5lciwge1xuICAgICAgICBmbjogKGVycm9yKT0+Ly8gVE9ETzogRml4IGRpc2FibGVkIGVzbGludCBydWxlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICByZW5kZXJFcnJvcih7XG4gICAgICAgICAgICAgICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgICAgICAgICAgICAgZXJyOiBlcnJvclxuICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PmNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbmRlcmluZyBwYWdlOiAnLCBlcnIpKVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcm91dGVyQ29udGV4dC5Sb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiAoMCwgX3JvdXRlcikubWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcilcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hlYWRNYW5hZ2VyQ29udGV4dC5IZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGhlYWRNYW5hZ2VyXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9pbWFnZUNvbmZpZ0NvbnRleHQuSW1hZ2VDb25maWdDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUU1xuICAgIH0sIGNoaWxkcmVuKSkpKTtcbn1cbmNvbnN0IHdyYXBBcHAgPSAoQXBwKT0+KHdyYXBwZWRBcHBQcm9wcyk9PntcbiAgICAgICAgY29uc3QgYXBwUHJvcHMgPSBfZXh0ZW5kcyh7fSwgd3JhcHBlZEFwcFByb3BzLCB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgICAgICAgIGVycjogaW5pdGlhbERhdGEuZXJyLFxuICAgICAgICAgICAgcm91dGVyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcENvbnRhaW5lciwgbnVsbCwgcmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpKTtcbiAgICB9O1xuLy8gVGhpcyBtZXRob2QgaGFuZGxlcyBhbGwgcnVudGltZSBhbmQgZGVidWcgZXJyb3JzLlxuLy8gNDA0IGFuZCA1MDAgZXJyb3JzIGFyZSBzcGVjaWFsIGtpbmQgb2YgZXJyb3JzXG4vLyBhbmQgdGhleSBhcmUgc3RpbGwgaGFuZGxlIHZpYSB0aGUgbWFpbiByZW5kZXIgbWV0aG9kLlxuZnVuY3Rpb24gcmVuZGVyRXJyb3IocmVuZGVyRXJyb3JQcm9wcykge1xuICAgIGxldCB7IEFwcCAsIGVyciAgfSA9IHJlbmRlckVycm9yUHJvcHM7XG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQgcnVudGltZSBlcnJvcnMgYXJlIGNhdWdodCBieSBvdXIgb3ZlcmxheVxuICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gQSBOZXh0LmpzIHJlbmRlcmluZyBydW50aW1lIGVycm9yIGlzIGFsd2F5cyB1bnJlY292ZXJhYmxlXG4gICAgICAgIC8vIEZJWE1FOiBsZXQncyBtYWtlIHRoaXMgcmVjb3ZlcmFibGUgKGVycm9yIGluIEdJUCBjbGllbnQtdHJhbnNpdGlvbilcbiAgICAgICAgd2VicGFja0hNUi5vblVucmVjb3ZlcmFibGVFcnJvcigpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbmRlciBhbiBlbXB0eSA8QXBwPiBzbyB0aGF0IHRoZSBgPFJlYWN0RGV2T3ZlcmxheT5gIGNhblxuICAgICAgICAvLyByZW5kZXIgaXRzZWxmLlxuICAgICAgICAvLyBUT0RPOiBGaXggZGlzYWJsZWQgZXNsaW50IHJ1bGVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gZG9SZW5kZXIoe1xuICAgICAgICAgICAgQXBwOiAoKT0+bnVsbCxcbiAgICAgICAgICAgIHByb3BzOiB7fSxcbiAgICAgICAgICAgIENvbXBvbmVudDogKCk9Pm51bGwsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBsb2cgdGhlIGVycm9yIHRvIHRoZSBjb25zb2xlLCBvdGhlcndpc2UgdXNlcnMgY2FuJ3QgdHJhY2sgZG93biBpc3N1ZXMuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIGNvbnNvbGUuZXJyb3IoYEEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCwgc2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvY2xpZW50LXNpZGUtZXhjZXB0aW9uLW9jY3VycmVkYCk7XG4gICAgcmV0dXJuIHBhZ2VMb2FkZXIubG9hZFBhZ2UoJy9fZXJyb3InKS50aGVuKCh7IHBhZ2U6IEVycm9yQ29tcG9uZW50ICwgc3R5bGVTaGVldHMgIH0pPT57XG4gICAgICAgIHJldHVybiAobGFzdEFwcFByb3BzID09IG51bGwgPyB2b2lkIDAgOiBsYXN0QXBwUHJvcHMuQ29tcG9uZW50KSA9PT0gRXJyb3JDb21wb25lbnQgPyBpbXBvcnQoJy4uL3BhZ2VzL19lcnJvcicpLnRoZW4oKGVycm9yTW9kdWxlKT0+e1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydCgnLi4vcGFnZXMvX2FwcCcpLnRoZW4oKGFwcE1vZHVsZSk9PntcbiAgICAgICAgICAgICAgICBBcHAgPSBhcHBNb2R1bGUuZGVmYXVsdDtcbiAgICAgICAgICAgICAgICByZW5kZXJFcnJvclByb3BzLkFwcCA9IEFwcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JNb2R1bGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbigobSk9Pih7XG4gICAgICAgICAgICAgICAgRXJyb3JDb21wb25lbnQ6IG0uZGVmYXVsdCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgICAgIH0pKSA6IHtcbiAgICAgICAgICAgIEVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgc3R5bGVTaGVldHNcbiAgICAgICAgfTtcbiAgICB9KS50aGVuKCh7IEVycm9yQ29tcG9uZW50ICwgc3R5bGVTaGVldHMgIH0pPT57XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgZG8gYSBub3JtYWwgcmVuZGVyIHdpdGggdGhlIGBFcnJvckNvbXBvbmVudGAgYXMgY29tcG9uZW50LlxuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gaGVyZSB1cG9uIGluaXRpYWwgcmVuZGVyLCB3ZSBjYW4gdXNlIHRoZSBwcm9wcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBjYWxsIGBnZXRJbml0aWFsUHJvcHNgIG9uIGBBcHBgIGJlZm9yZSBtb3VudGluZy5cbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHdyYXBBcHAoQXBwKTtcbiAgICAgICAgY29uc3QgYXBwQ3R4ID0ge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICByb3V0ZXIsXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWU6IGluaXRpYWxEYXRhLnBhZ2UsXG4gICAgICAgICAgICAgICAgcXVlcnk6IGluaXRpYWxEYXRhLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzUGF0aCxcbiAgICAgICAgICAgICAgICBBcHBUcmVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKChyZWYgPSByZW5kZXJFcnJvclByb3BzLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLmVycikgPyByZW5kZXJFcnJvclByb3BzLnByb3BzIDogKDAsIF91dGlscykubG9hZEdldEluaXRpYWxQcm9wcyhBcHAsIGFwcEN0eCkpLnRoZW4oKGluaXRQcm9wcyk9Pi8vIFRPRE86IEZpeCBkaXNhYmxlZCBlc2xpbnQgcnVsZVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgZG9SZW5kZXIoX2V4dGVuZHMoe30sIHJlbmRlckVycm9yUHJvcHMsIHtcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdFByb3BzXG4gICAgICAgICAgICB9KSkpO1xuICAgIH0pO1xufVxuLy8gRHVtbXkgY29tcG9uZW50IHRoYXQgd2UgcmVuZGVyIGFzIGEgY2hpbGQgb2YgUm9vdCBzbyB0aGF0IHdlIGNhblxuLy8gdG9nZ2xlIHRoZSBjb3JyZWN0IHN0eWxlcyBiZWZvcmUgdGhlIHBhZ2UgaXMgcmVuZGVyZWQuXG5mdW5jdGlvbiBIZWFkKHsgY2FsbGJhY2sgIH0pIHtcbiAgICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZFxuICAgIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlLlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdCgoKT0+Y2FsbGJhY2soKSwgW1xuICAgICAgICBjYWxsYmFja1xuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxubGV0IHJlYWN0Um9vdCA9IG51bGw7XG4vLyBPbiBpbml0aWFsIHJlbmRlciBhIGh5ZHJhdGUgc2hvdWxkIGFsd2F5cyBoYXBwZW5cbmxldCBzaG91bGRIeWRyYXRlID0gdHJ1ZTtcbmZ1bmN0aW9uIGNsZWFyTWFya3MoKSB7XG4gICAgW1xuICAgICAgICAnYmVmb3JlUmVuZGVyJyxcbiAgICAgICAgJ2FmdGVySHlkcmF0ZScsXG4gICAgICAgICdhZnRlclJlbmRlcicsXG4gICAgICAgICdyb3V0ZUNoYW5nZSdcbiAgICBdLmZvckVhY2goKG1hcmspPT5wZXJmb3JtYW5jZS5jbGVhck1hcmtzKG1hcmspKTtcbn1cbmZ1bmN0aW9uIG1hcmtIeWRyYXRlQ29tcGxldGUoKSB7XG4gICAgaWYgKCFfdXRpbHMuU1QpIHJldHVybjtcbiAgICBwZXJmb3JtYW5jZS5tYXJrKCdhZnRlckh5ZHJhdGUnKSAvLyBtYXJrIGVuZCBvZiBoeWRyYXRpb25cbiAgICA7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1iZWZvcmUtaHlkcmF0aW9uJywgJ25hdmlnYXRpb25TdGFydCcsICdiZWZvcmVSZW5kZXInKTtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLWh5ZHJhdGlvbicsICdiZWZvcmVSZW5kZXInLCAnYWZ0ZXJIeWRyYXRlJyk7XG4gICAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgICAgIHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoJ05leHQuanMtaHlkcmF0aW9uJykuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgfVxuICAgIGNsZWFyTWFya3MoKTtcbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJDb21wbGV0ZSgpIHtcbiAgICBpZiAoIV91dGlscy5TVCkgcmV0dXJuO1xuICAgIHBlcmZvcm1hbmNlLm1hcmsoJ2FmdGVyUmVuZGVyJykgLy8gbWFyayBlbmQgb2YgcmVuZGVyXG4gICAgO1xuICAgIGNvbnN0IG5hdlN0YXJ0RW50cmllcyA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoJ3JvdXRlQ2hhbmdlJywgJ21hcmsnKTtcbiAgICBpZiAoIW5hdlN0YXJ0RW50cmllcy5sZW5ndGgpIHJldHVybjtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInLCBuYXZTdGFydEVudHJpZXNbMF0ubmFtZSwgJ2JlZm9yZVJlbmRlcicpO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ05leHQuanMtcmVuZGVyJywgJ2JlZm9yZVJlbmRlcicsICdhZnRlclJlbmRlcicpO1xuICAgIGlmIChvblBlcmZFbnRyeSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdOZXh0LmpzLXJlbmRlcicpLmZvckVhY2gob25QZXJmRW50cnkpO1xuICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTtcbiAgICB9XG4gICAgY2xlYXJNYXJrcygpO1xuICAgIFtcbiAgICAgICAgJ05leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlcicsXG4gICAgICAgICdOZXh0LmpzLXJlbmRlcidcbiAgICBdLmZvckVhY2goKG1lYXN1cmUpPT5wZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmUpKTtcbn1cbmZ1bmN0aW9uIHJlbmRlclJlYWN0RWxlbWVudChkb21FbCwgZm4pIHtcbiAgICAvLyBtYXJrIHN0YXJ0IG9mIGh5ZHJhdGUvcmVuZGVyXG4gICAgaWYgKF91dGlscy5TVCkge1xuICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKCdiZWZvcmVSZW5kZXInKTtcbiAgICB9XG4gICAgY29uc3QgcmVhY3RFbCA9IGZuKHNob3VsZEh5ZHJhdGUgPyBtYXJrSHlkcmF0ZUNvbXBsZXRlIDogbWFya1JlbmRlckNvbXBsZXRlKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1JFQUNUX1JPT1QpIHtcbiAgICAgICAgaWYgKCFyZWFjdFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFVubGlrZSB3aXRoIGNyZWF0ZVJvb3QsIHlvdSBkb24ndCBuZWVkIGEgc2VwYXJhdGUgcm9vdC5yZW5kZXIoKSBjYWxsIGhlcmVcbiAgICAgICAgICAgIHJlYWN0Um9vdCA9IFJlYWN0RE9NLmh5ZHJhdGVSb290KGRvbUVsLCByZWFjdEVsKTtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBzaG91bGRIeWRyYXRlIHZhcmlhYmxlIHdoZW4gUmVhY3QgMTggaXMgc3RhYmxlIGFzIGl0IGNhbiBkZXBlbmQgb24gYHJlYWN0Um9vdGAgZXhpc3RpbmdcbiAgICAgICAgICAgIHNob3VsZEh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VHJhbnNpdGlvbiA9IF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbjtcbiAgICAgICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgIHJlYWN0Um9vdC5yZW5kZXIocmVhY3RFbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBjaGVjayBmb3IgYC5oeWRyYXRlYCBpcyB0aGVyZSB0byBzdXBwb3J0IFJlYWN0IGFsdGVybmF0aXZlcyBsaWtlIHByZWFjdFxuICAgICAgICBpZiAoc2hvdWxkSHlkcmF0ZSkge1xuICAgICAgICAgICAgUmVhY3RET00uaHlkcmF0ZShyZWFjdEVsLCBkb21FbCk7XG4gICAgICAgICAgICBzaG91bGRIeWRyYXRlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdERPTS5yZW5kZXIocmVhY3RFbCwgZG9tRWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gUm9vdCh7IGNhbGxiYWNrcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgLy8gV2UgdXNlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGd1YXJhbnRlZSB0aGUgY2FsbGJhY2tzIGFyZSBleGVjdXRlZFxuICAgIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlTGF5b3V0RWZmZWN0KCgpPT5jYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spPT5jYWxsYmFjaygpKSwgW1xuICAgICAgICBjYWxsYmFja3NcbiAgICBdKTtcbiAgICAvLyBXZSBzaG91bGQgYXNrIHRvIG1lYXN1cmUgdGhlIFdlYiBWaXRhbHMgYWZ0ZXIgcmVuZGVyaW5nIGNvbXBsZXRlcyBzbyB3ZVxuICAgIC8vIGRvbid0IGNhdXNlIGFueSBoeWRyYXRpb24gZGVsYXk6XG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgICgwLCBfcGVyZm9ybWFuY2VSZWxheWVyKS5kZWZhdWx0KG9uUGVyZkVudHJ5KTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRCA9IHRydWU7XG4gICAgICAgICAgICBpZiAod2luZG93Ll9fTkVYVF9IWURSQVRFRF9DQikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBkb1JlbmRlcihpbnB1dCkge1xuICAgIGxldCB7IEFwcCAsIENvbXBvbmVudCAsIHByb3BzICwgZXJyICB9ID0gaW5wdXQ7XG4gICAgbGV0IHN0eWxlU2hlZXRzID0gJ2luaXRpYWwnIGluIGlucHV0ID8gdW5kZWZpbmVkIDogaW5wdXQuc3R5bGVTaGVldHM7XG4gICAgQ29tcG9uZW50ID0gQ29tcG9uZW50IHx8IGxhc3RBcHBQcm9wcy5Db21wb25lbnQ7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCBsYXN0QXBwUHJvcHMucHJvcHM7XG4gICAgY29uc3QgYXBwUHJvcHMgPSBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBlcnIsXG4gICAgICAgIHJvdXRlclxuICAgIH0pO1xuICAgIC8vIGxhc3RBcHBQcm9wcyBoYXMgdG8gYmUgc2V0IGJlZm9yZSBSZWFjdERvbS5yZW5kZXIgdG8gYWNjb3VudCBmb3IgUmVhY3REb20gdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgbGFzdEFwcFByb3BzID0gYXBwUHJvcHM7XG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgbGV0IHJlc29sdmVQcm9taXNlO1xuICAgIGNvbnN0IHJlbmRlclByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBpZiAobGFzdFJlbmRlclJlamVjdCkge1xuICAgICAgICAgICAgbGFzdFJlbmRlclJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVQcm9taXNlID0gKCk9PntcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NhbmNlbCByZW5kZXJpbmcgcm91dGUnKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaGFzIGEgcmV0dXJuIHR5cGUgdG8gZW5zdXJlIGl0IGRvZXNuJ3Qgc3RhcnQgcmV0dXJuaW5nIGFcbiAgICAvLyBQcm9taXNlLiBJdCBzaG91bGQgcmVtYWluIHN5bmNocm9ub3VzLlxuICAgIGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgIGlmICghc3R5bGVTaGVldHMgfHwgLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFN0eWxlVGFncyA9IGxvb3NlVG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZVtkYXRhLW4taHJlZl0nKSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRIcmVmcyA9IG5ldyBTZXQoY3VycmVudFN0eWxlVGFncy5tYXAoKHRhZyk9PnRhZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtbi1ocmVmJykpKTtcbiAgICAgICAgY29uc3Qgbm9zY3JpcHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdub3NjcmlwdFtkYXRhLW4tY3NzXScpO1xuICAgICAgICBjb25zdCBub25jZSA9IG5vc2NyaXB0ID09IG51bGwgPyB2b2lkIDAgOiBub3NjcmlwdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbi1jc3MnKTtcbiAgICAgICAgc3R5bGVTaGVldHMuZm9yRWFjaCgoeyBocmVmICwgdGV4dCAgfSk9PntcbiAgICAgICAgICAgIGlmICghY3VycmVudEhyZWZzLmhhcyhocmVmKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ2RhdGEtbi1ocmVmJywgaHJlZik7XG4gICAgICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdtZWRpYScsICd4Jyk7XG4gICAgICAgICAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkhlYWRDb21taXQoKSB7XG4gICAgICAgIGlmICgvLyBXZSB1c2UgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICAgICAgLy8gdW5sZXNzIHdlJ3JlIGluIHByb2R1Y3Rpb246XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgLy8gV2UgY2FuIHNraXAgdGhpcyBkdXJpbmcgaHlkcmF0aW9uLiBSdW5uaW5nIGl0IHdvbnQgY2F1c2UgYW55IGhhcm0sIGJ1dFxuICAgICAgICAvLyB3ZSBtYXkgYXMgd2VsbCBzYXZlIHRoZSBDUFUgY3ljbGVzOlxuICAgICAgICBzdHlsZVNoZWV0cyAmJiAvLyBFbnN1cmUgdGhpcyByZW5kZXIgd2FzIG5vdCBjYW5jZWxlZFxuICAgICAgICAhY2FuY2VsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRIcmVmcyA9IG5ldyBTZXQoc3R5bGVTaGVldHMubWFwKChzKT0+cy5ocmVmKSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3R5bGVUYWdzID0gbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlW2RhdGEtbi1ocmVmXScpKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRIcmVmcyA9IGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpPT50YWcuZ2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicpKTtcbiAgICAgICAgICAgIC8vIFRvZ2dsZSBgPHN0eWxlPmAgdGFncyBvbiBvciBvZmYgZGVwZW5kaW5nIG9uIGlmIHRoZXkncmUgbmVlZGVkOlxuICAgICAgICAgICAgZm9yKGxldCBpZHggPSAwOyBpZHggPCBjdXJyZW50SHJlZnMubGVuZ3RoOyArK2lkeCl7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2lyZWRIcmVmcy5oYXMoY3VycmVudEhyZWZzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCAneCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlb3JkZXIgc3R5bGVzIGludG8gaW50ZW5kZWQgb3JkZXI6XG4gICAgICAgICAgICBsZXQgcmVmZXJlbmNlTm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ25vc2NyaXB0W2RhdGEtbi1jc3NdJyk7XG4gICAgICAgICAgICBpZiAoLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHsgaHJlZiAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS1uLWhyZWY9XCIke2hyZWZ9XCJdYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YXJnZXRUYWcsIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHRhcmdldFRhZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgY2xlYW4gdXAgc2VydmVyIHJlbmRlcmVkIHN0eWxlc2hlZXRzOlxuICAgICAgICAgICAgbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbZGF0YS1uLXBdJykpLmZvckVhY2goKGVsKT0+e1xuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LnNjcm9sbCkge1xuICAgICAgICAgICAgY29uc3QgaHRtbEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yO1xuICAgICAgICAgICAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnYXV0byc7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oaW5wdXQuc2Nyb2xsLngsIGlucHV0LnNjcm9sbC55KTtcbiAgICAgICAgICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gZXhpc3Rpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Sb290Q29tbWl0KCkge1xuICAgICAgICByZXNvbHZlUHJvbWlzZSgpO1xuICAgIH1cbiAgICBvblN0YXJ0KCk7XG4gICAgY29uc3QgZWxlbSA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhlYWQsIHtcbiAgICAgICAgY2FsbGJhY2s6IG9uSGVhZENvbW1pdFxuICAgIH0pLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGFpbmVyLCBudWxsLCByZW5kZXJBcHAoQXBwLCBhcHBQcm9wcyksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcG9ydGFsLlBvcnRhbCwge1xuICAgICAgICB0eXBlOiBcIm5leHQtcm91dGUtYW5ub3VuY2VyXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JvdXRlQW5ub3VuY2VyLlJvdXRlQW5ub3VuY2VyLCBudWxsKSkpKTtcbiAgICAvLyBXZSBjYXRjaCBydW50aW1lIGVycm9ycyB1c2luZyBjb21wb25lbnREaWRDYXRjaCB3aGljaCB3aWxsIHRyaWdnZXIgcmVuZGVyRXJyb3JcbiAgICByZW5kZXJSZWFjdEVsZW1lbnQoYXBwRWxlbWVudCwgKGNhbGxiYWNrKT0+LyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJvb3QsIHtcbiAgICAgICAgICAgIGNhbGxiYWNrczogW1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIG9uUm9vdENvbW1pdFxuICAgICAgICAgICAgXVxuICAgICAgICB9LCBwcm9jZXNzLmVudi5fX05FWFRfU1RSSUNUX01PREUgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuU3RyaWN0TW9kZSwgbnVsbCwgZWxlbSkgOiBlbGVtKSk7XG4gICAgcmV0dXJuIHJlbmRlclByb21pc2U7XG59XG5mdW5jdGlvbiByZW5kZXIocmVuZGVyaW5nUHJvcHMpIHtcbiAgICByZXR1cm4gX3JlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX3JlbmRlcigpIHtcbiAgICBfcmVuZGVyID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbioocmVuZGVyaW5nUHJvcHMpIHtcbiAgICAgICAgaWYgKHJlbmRlcmluZ1Byb3BzLmVycikge1xuICAgICAgICAgICAgeWllbGQgcmVuZGVyRXJyb3IocmVuZGVyaW5nUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB5aWVsZCBkb1JlbmRlcihyZW5kZXJpbmdQcm9wcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyRXJyID0gKDAsIF9pc0Vycm9yKS5nZXRQcm9wZXJFcnJvcihlcnIpO1xuICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGF0aW9uIGVycm9yc1xuICAgICAgICAgICAgaWYgKHJlbmRlckVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZW5kZXJFcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhpcyBlcnJvciBpcyBkaXNwbGF5ZWQgaW4gdGhlIG92ZXJsYXkgaW4gZGV2ZWxvcG1lbnRcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJlbmRlckVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHJlbmRlckVycm9yKF9leHRlbmRzKHt9LCByZW5kZXJpbmdQcm9wcywge1xuICAgICAgICAgICAgICAgIGVycjogcmVuZGVyRXJyXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3JlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gaHlkcmF0ZShvcHRzKSB7XG4gICAgcmV0dXJuIF9oeWRyYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfaHlkcmF0ZSgpIHtcbiAgICBfaHlkcmF0ZSA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKG9wdHMpIHtcbiAgICAgICAgbGV0IGluaXRpYWxFcnIgPSBpbml0aWFsRGF0YS5lcnI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhcHBFbnRyeXBvaW50ID0geWllbGQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludCgnL19hcHAnKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIGFwcEVudHJ5cG9pbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBhcHBFbnRyeXBvaW50LmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjb21wb25lbnQ6IGFwcCAsIGV4cG9ydHM6IG1vZCAgfSA9IGFwcEVudHJ5cG9pbnQ7XG4gICAgICAgICAgICBDYWNoZWRBcHAgPSBhcHA7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5yZXBvcnRXZWJWaXRhbHMpIHtcbiAgICAgICAgICAgICAgICBvblBlcmZFbnRyeSA9ICh7IGlkICwgbmFtZSAsIHN0YXJ0VGltZSAsIHZhbHVlICwgZHVyYXRpb24gLCBlbnRyeVR5cGUgLCBlbnRyaWVzICB9KT0+e1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21iaW5lcyB0aW1lc3RhbXAgd2l0aCByYW5kb20gbnVtYmVyIGZvciB1bmlxdWUgSURcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlSUQgPSBgJHtEYXRlLm5vdygpfS0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICg5ZTEyIC0gMSkpICsgMWUxMn1gO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGVyZlN0YXJ0RW50cnk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJmU3RhcnRFbnRyeSA9IGVudHJpZXNbMF0uc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdlYlZpdGFscyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCB8fCB1bmlxdWVJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSB8fCBwZXJmU3RhcnRFbnRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSA9PSBudWxsID8gZHVyYXRpb24gOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBlbnRyeVR5cGUgPT09ICdtYXJrJyB8fCBlbnRyeVR5cGUgPT09ICdtZWFzdXJlJyA/ICdjdXN0b20nIDogJ3dlYi12aXRhbCdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbW9kLnJlcG9ydFdlYlZpdGFscyh3ZWJWaXRhbHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYWdlRW50cnlwb2ludCA9IC8vIFRoZSBkZXYgc2VydmVyIGZhaWxzIHRvIHNlcnZlIHNjcmlwdCBhc3NldHMgd2hlbiB0aGVyZSdzIGEgaHlkcmF0aW9uXG4gICAgICAgICAgICAvLyBlcnJvciwgc28gd2UgbmVlZCB0byBza2lwIHdhaXRpbmcgZm9yIHRoZSBlbnRyeXBvaW50LlxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgaW5pdGlhbERhdGEuZXJyID8ge1xuICAgICAgICAgICAgICAgIGVycm9yOiBpbml0aWFsRGF0YS5lcnJcbiAgICAgICAgICAgIH0gOiB5aWVsZCBwYWdlTG9hZGVyLnJvdXRlTG9hZGVyLndoZW5FbnRyeXBvaW50KGluaXRpYWxEYXRhLnBhZ2UpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcGFnZUVudHJ5cG9pbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBwYWdlRW50cnlwb2ludC5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENhY2hlZENvbXBvbmVudCA9IHBhZ2VFbnRyeXBvaW50LmNvbXBvbmVudDtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgIH0gPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDYWNoZWRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7aW5pdGlhbERhdGEucGFnZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhdGNoZXMgZXJyb3JzIGxpa2UgdGhyb3dpbmcgaW4gdGhlIHRvcCBsZXZlbCBvZiBhIG1vZHVsZVxuICAgICAgICAgICAgaW5pdGlhbEVyciA9ICgwLCBfaXNFcnJvcikuZ2V0UHJvcGVyRXJyb3IoZXJyb3IxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2V0U2VydmVyRXJyb3IgLCAgfSA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9kaXN0L2NsaWVudCcpO1xuICAgICAgICAgICAgLy8gU2VydmVyLXNpZGUgcnVudGltZSBlcnJvcnMgbmVlZCB0byBiZSByZS10aHJvd24gb24gdGhlIGNsaWVudC1zaWRlIHNvXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSBvdmVybGF5IGlzIHJlbmRlcmVkLlxuICAgICAgICAgICAgaWYgKGluaXRpYWxFcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbEVyciA9PT0gaW5pdGlhbERhdGEuZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgZXJyb3Igb2JqZWN0LiBXZSBgdGhyb3dgIGl0IGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgc2V0IHRoZSBgc3RhY2tgIHdoZW4gdGhyb3duLCBhbmQgd2Ugd2FudCB0byBlbnN1cmUgb3VycyBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBvdmVycmlkZGVuIHdoZW4gd2UgcmUtdGhyb3cgaXQgYmVsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluaXRpYWxFcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IGluaXRpYWxFcnIubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrID0gaW5pdGlhbEVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGdldFNlcnZlckVycm9yKGVycm9yLCBpbml0aWFsRXJyLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGluaXRpYWxFcnI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkpIHtcbiAgICAgICAgICAgIHlpZWxkIHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKGluaXRpYWxEYXRhLmR5bmFtaWNJZHMpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMucm91dGVyID0gcm91dGVyID0gKDAsIF9yb3V0ZXIpLmNyZWF0ZVJvdXRlcihpbml0aWFsRGF0YS5wYWdlLCBpbml0aWFsRGF0YS5xdWVyeSwgYXNQYXRoLCB7XG4gICAgICAgICAgICBpbml0aWFsUHJvcHM6IGluaXRpYWxEYXRhLnByb3BzLFxuICAgICAgICAgICAgcGFnZUxvYWRlcixcbiAgICAgICAgICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICB3cmFwQXBwLFxuICAgICAgICAgICAgZXJyOiBpbml0aWFsRXJyLFxuICAgICAgICAgICAgaXNGYWxsYmFjazogQm9vbGVhbihpbml0aWFsRGF0YS5pc0ZhbGxiYWNrKSxcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbjogKGluZm8sIEFwcCwgc2Nyb2xsKT0+cmVuZGVyKE9iamVjdC5hc3NpZ24oe30sIGluZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgQXBwLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBsb2NhbGU6IGluaXRpYWxEYXRhLmxvY2FsZSxcbiAgICAgICAgICAgIGxvY2FsZXM6IGluaXRpYWxEYXRhLmxvY2FsZXMsXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgZG9tYWluTG9jYWxlczogaW5pdGlhbERhdGEuZG9tYWluTG9jYWxlcyxcbiAgICAgICAgICAgIGlzUHJldmlldzogaW5pdGlhbERhdGEuaXNQcmV2aWV3XG4gICAgICAgIH0pO1xuICAgICAgICBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUgPSB5aWVsZCByb3V0ZXIuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2U7XG4gICAgICAgIGNvbnN0IHJlbmRlckN0eCA9IHtcbiAgICAgICAgICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgICAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgICAgICAgICAgcHJvcHM6IGluaXRpYWxEYXRhLnByb3BzLFxuICAgICAgICAgICAgZXJyOiBpbml0aWFsRXJyXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJlZm9yZVJlbmRlcikge1xuICAgICAgICAgICAgeWllbGQgb3B0cy5iZWZvcmVSZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXIocmVuZGVyQ3R4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2h5ZHJhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaW5pdGlhbGl6ZSIsImh5ZHJhdGUiLCJlbWl0dGVyIiwicm91dGVyIiwidmVyc2lvbiIsIl9hc3luY190b19nZW5lcmF0b3IiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9leHRlbmRzIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZWFjdCIsIl9oZWFkTWFuYWdlckNvbnRleHQiLCJfbWl0dCIsIl9yb3V0ZXJDb250ZXh0IiwiX2lzRHluYW1pYyIsIl9xdWVyeXN0cmluZyIsIl9ydW50aW1lQ29uZmlnIiwiX3V0aWxzIiwiX3BvcnRhbCIsIl9oZWFkTWFuYWdlciIsIl9wYWdlTG9hZGVyIiwiX3BlcmZvcm1hbmNlUmVsYXllciIsIl9yb3V0ZUFubm91bmNlciIsIl9yb3V0ZXIiLCJfaXNFcnJvciIsIl9pbWFnZUNvbmZpZ0NvbnRleHQiLCJfcmVtb3ZlQmFzZVBhdGgiLCJfaGFzQmFzZVBhdGgiLCJSZWFjdERPTSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUkVBQ1RfUk9PVCIsImxvb3NlVG9BcnJheSIsImlucHV0Iiwic2xpY2UiLCJjYWxsIiwiaW5pdGlhbERhdGEiLCJkZWZhdWx0TG9jYWxlIiwidW5kZWZpbmVkIiwiYXNQYXRoIiwicGFnZUxvYWRlciIsImFwcEVsZW1lbnQiLCJoZWFkTWFuYWdlciIsImluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSIsImxhc3RBcHBQcm9wcyIsImxhc3RSZW5kZXJSZWplY3QiLCJ3ZWJwYWNrSE1SIiwiQ2FjaGVkQXBwIiwib25QZXJmRW50cnkiLCJDYWNoZWRDb21wb25lbnQiLCJzZWxmIiwiX19uZXh0X3JlcXVpcmVfXyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJDb250YWluZXIiLCJjb21wb25lbnREaWRDYXRjaCIsImNvbXBvbmVudEVyciIsImluZm8iLCJwcm9wcyIsImZuIiwiY29tcG9uZW50RGlkTW91bnQiLCJzY3JvbGxUb0hhc2giLCJpc1NzciIsInBhZ2UiLCJpc0ZhbGxiYWNrIiwibmV4dEV4cG9ydCIsImlzRHluYW1pY1JvdXRlIiwicGF0aG5hbWUiLCJsb2NhdGlvbiIsInNlYXJjaCIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJfX05fU1NHIiwicmVwbGFjZSIsIlN0cmluZyIsImFzc2lnbiIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJxdWVyeSIsIlVSTFNlYXJjaFBhcmFtcyIsIl9oIiwic2hhbGxvdyIsImNhdGNoIiwiZXJyIiwiY2FuY2VsbGVkIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiaGFzaCIsInN1YnN0cmluZyIsImVsIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInNldFRpbWVvdXQiLCJzY3JvbGxJbnRvVmlldyIsInJlbmRlciIsImNoaWxkcmVuIiwiUmVhY3REZXZPdmVybGF5IiwiY3JlYXRlRWxlbWVudCIsIkNvbXBvbmVudCIsIl9pbml0aWFsaXplIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJvcHRzIiwicHJlZml4Iiwibm9ybWFsaXplTG9jYWxlUGF0aCIsImRldGVjdERvbWFpbkxvY2FsZSIsInBhcnNlUmVsYXRpdmVVcmwiLCJmb3JtYXRVcmwiLCJwYXJzZWRBcyIsImxvY2FsZVBhdGhSZXN1bHQiLCJkZXRlY3RlZERvbWFpbiIsImluaXRTY3JpcHRMb2FkZXIiLCJyZWdpc3RlciIsIkpTT04iLCJwYXJzZSIsInRleHRDb250ZW50Iiwid2luZG93IiwiX19ORVhUX0RBVEFfXyIsImFzc2V0UHJlZml4IiwiX193ZWJwYWNrX3B1YmxpY19wYXRoX18iLCJzZXRDb25maWciLCJzZXJ2ZXJSdW50aW1lQ29uZmlnIiwicHVibGljUnVudGltZUNvbmZpZyIsInJ1bnRpbWVDb25maWciLCJnZXRVUkwiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsImxvY2FsZXMiLCJkZXRlY3RlZExvY2FsZSIsImxvY2FsZSIsIl9fTkVYVF9JMThOX0RPTUFJTlMiLCJob3N0bmFtZSIsInNjcmlwdExvYWRlciIsImJ1aWxkSWQiLCJyIiwiZiIsInJvdXRlTG9hZGVyIiwib25FbnRyeXBvaW50IiwiX19ORVhUX1AiLCJtYXAiLCJwIiwicHVzaCIsImdldElzU3NyIiwicmVuZGVyQXBwIiwiQXBwIiwiYXBwUHJvcHMiLCJBcHBDb250YWluZXIiLCJlcnJvciIsInJlbmRlckVycm9yIiwiY29uc29sZSIsIlJvdXRlckNvbnRleHQiLCJQcm92aWRlciIsIm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsIkltYWdlQ29uZmlnQ29udGV4dCIsIl9fTkVYVF9JTUFHRV9PUFRTIiwid3JhcEFwcCIsIndyYXBwZWRBcHBQcm9wcyIsInJlbmRlckVycm9yUHJvcHMiLCJvblVucmVjb3ZlcmFibGVFcnJvciIsImRvUmVuZGVyIiwic3R5bGVTaGVldHMiLCJsb2FkUGFnZSIsInRoZW4iLCJFcnJvckNvbXBvbmVudCIsImVycm9yTW9kdWxlIiwiYXBwTW9kdWxlIiwibSIsInJlZiIsIkFwcFRyZWUiLCJhcHBDdHgiLCJjdHgiLCJQcm9taXNlIiwicmVzb2x2ZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJpbml0UHJvcHMiLCJIZWFkIiwiY2FsbGJhY2siLCJ1c2VMYXlvdXRFZmZlY3QiLCJyZWFjdFJvb3QiLCJzaG91bGRIeWRyYXRlIiwiY2xlYXJNYXJrcyIsImZvckVhY2giLCJtYXJrIiwicGVyZm9ybWFuY2UiLCJtYXJrSHlkcmF0ZUNvbXBsZXRlIiwiU1QiLCJtZWFzdXJlIiwiZ2V0RW50cmllc0J5TmFtZSIsIm1hcmtSZW5kZXJDb21wbGV0ZSIsIm5hdlN0YXJ0RW50cmllcyIsImxlbmd0aCIsIm5hbWUiLCJjbGVhck1lYXN1cmVzIiwicmVuZGVyUmVhY3RFbGVtZW50IiwiZG9tRWwiLCJyZWFjdEVsIiwiaHlkcmF0ZVJvb3QiLCJzdGFydFRyYW5zaXRpb24iLCJSb290IiwiY2FsbGJhY2tzIiwidXNlRWZmZWN0IiwiX19ORVhUX1RFU1RfTU9ERSIsIl9fTkVYVF9IWURSQVRFRCIsIl9fTkVYVF9IWURSQVRFRF9DQiIsIm9uU3RhcnQiLCJjdXJyZW50U3R5bGVUYWdzIiwicXVlcnlTZWxlY3RvckFsbCIsImN1cnJlbnRIcmVmcyIsIlNldCIsInRhZyIsImdldEF0dHJpYnV0ZSIsIm5vc2NyaXB0IiwicXVlcnlTZWxlY3RvciIsIm5vbmNlIiwiaHJlZiIsInRleHQiLCJoYXMiLCJzdHlsZVRhZyIsInNldEF0dHJpYnV0ZSIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwib25IZWFkQ29tbWl0IiwiY2FuY2VsZWQiLCJkZXNpcmVkSHJlZnMiLCJzIiwiaWR4IiwicmVtb3ZlQXR0cmlidXRlIiwicmVmZXJlbmNlTm9kZSIsInRhcmdldFRhZyIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJuZXh0U2libGluZyIsInJlbW92ZUNoaWxkIiwic2Nyb2xsIiwiaHRtbEVsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJleGlzdGluZyIsInN0eWxlIiwic2Nyb2xsQmVoYXZpb3IiLCJzY3JvbGxUbyIsIngiLCJ5Iiwib25Sb290Q29tbWl0IiwicmVzb2x2ZVByb21pc2UiLCJyZW5kZXJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJlbGVtIiwiRnJhZ21lbnQiLCJQb3J0YWwiLCJ0eXBlIiwiUm91dGVBbm5vdW5jZXIiLCJfX05FWFRfU1RSSUNUX01PREUiLCJTdHJpY3RNb2RlIiwicmVuZGVyaW5nUHJvcHMiLCJfcmVuZGVyIiwicmVuZGVyRXJyIiwiZ2V0UHJvcGVyRXJyb3IiLCJfaHlkcmF0ZSIsImluaXRpYWxFcnIiLCJhcHBFbnRyeXBvaW50IiwiYXBwIiwibW9kIiwicGFnZUVudHJ5cG9pbnQiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJlcnJvcjEiLCJnZXRTZXJ2ZXJFcnJvciIsInJlbmRlckN0eCIsIndoZW5FbnRyeXBvaW50IiwiY29tcG9uZW50IiwicmVwb3J0V2ViVml0YWxzIiwiaWQiLCJzdGFydFRpbWUiLCJkdXJhdGlvbiIsImVudHJ5VHlwZSIsImVudHJpZXMiLCJ1bmlxdWVJRCIsIk1hdGgiLCJEYXRlIiwibm93IiwiZmxvb3IiLCJyYW5kb20iLCJwZXJmU3RhcnRFbnRyeSIsIndlYlZpdGFscyIsImxhYmVsIiwibWVzc2FnZSIsImUiLCJzdGFjayIsInNvdXJjZSIsIl9fTkVYVF9QUkVMT0FEUkVBRFkiLCJkeW5hbWljSWRzIiwiY3JlYXRlUm91dGVyIiwiaW5pdGlhbFByb3BzIiwiQm9vbGVhbiIsInN1YnNjcmlwdGlvbiIsImRvbWFpbkxvY2FsZXMiLCJpc1ByZXZpZXciLCJfaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSIsImluaXRpYWwiLCJiZWZvcmVSZW5kZXIiLCJfX2VzTW9kdWxlIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/index.js\n"));

/***/ })

});